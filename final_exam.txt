////////////Assignment 1//////////=====Write a lex program to count the number of comments, keywords, identifiers, words, lines, and spaces from input file==================win_flex count_analysis.lgcc lex.yy.c -o count_analysis.exe./count_analysis.exe input.txtdel lex.yy.cdel count_analysis.exe///input.txt/////int main() {    int a = 10;    float b = 20.5;    if (a < b)        a = a + 1;    return 0;}%{#include <stdio.h>#include <string.h>int commentCount = 0;int keywordCount = 0;int identifierCount = 0;int wordCount = 0;int lineCount = 0;int spaceCount = 0;char *keywordList[] = {    "int", "float", "char", "double", "for", "while",    "if", "else", "return", "void", "do", "switch",    "case", "break", "continue"};int totalKeywords = 15;%}%%"//".*                          { commentCount++; }                         /* Single line comment */"/*"([^*]|\*+[^*/])*\*+"/"      { commentCount++; }                         /* Multi-line comment */[ \t]+                          { spaceCount += yyleng; }                   /* Spaces & tabs */\n                              { lineCount++; }                            /* Count new lines */[a-zA-Z_][a-zA-Z0-9_]*          {                                   int i, isKeyword = 0;                                   for(i = 0; i < totalKeywords; i++) {                                       if(strcmp(yytext, keywordList[i]) == 0) {                                           keywordCount++;                                           isKeyword = 1;                                           break;                                       }                                   }                                   if(!isKeyword)                                       identifierCount++;                                   wordCount++;                                 }.                                { /* Ignore other characters */ }%%int main(int argc, char *argv[]) {    FILE *inputFile;    if(argc > 1)        inputFile = fopen(argv[1], "r");    else {        printf("Enter the input text below (Press Ctrl+D to end):\n");        inputFile = stdin;    }    if(!inputFile) {        printf("Error: Could not open file.\n");        return 1;    }    yyin = inputFile;    yylex();    printf("\n===== Code Analysis Summary =====\n");    printf("Total Comments     : %d\n", commentCount);    printf("Total Keywords     : %d\n", keywordCount);    printf("Total Identifiers  : %d\n", identifierCount);    printf("Total Words        : %d\n", wordCount);    printf("Total Lines        : %d\n", lineCount);    printf("Total Spaces       : %d\n", spaceCount);    return 0;}int yywrap() {    return 1;}experimenttt 2-startwithA%{#include <stdio.h>#include <string.h>int count = 0;   // to count words starting with A or a%}%%[Aa][a-zA-Z]*     { count++; }      // words starting with A or a.|\n              { /* ignore other characters */ }%%int main() {    printf("Enter text (press Ctrl+Z and Enter to end input):\n");    yylex();   // call the lexical analyzer    printf("\nTotal number of words starting with 'A' or 'a': %d\n", count);    return 0;}int yywrap() {    return 1;}conversion-lower to upper%{#include <stdio.h>%}%%[A-Z]    { printf("%c", yytext[0] + 32); }   /* Convert uppercase to lowercase */[a-z]    { printf("%c", yytext[0] - 32); }   /* Convert lowercase to uppercase */.|\n     { ECHO; }                           /* Print other characters as they are */%%int main(void) {    yylex();    return 0;}int yywrap(void) {    return 1;}experimennttt 4-dectohex%{#include <stdio.h>#include <stdlib.h>%}%%[0-9]+ {    int num = atoi(yytext);    printf("Hexadecimal of %d = %X\n", num, num);}.|\n  { ECHO; }%%int main() {    yylex();    return 0;}int yywrap() {    return 1;} dectobin%{#include <stdio.h>#include <stdlib.h>void dec_to_bin(int n) {    int binary[32], i = 0;    while(n > 0) {        binary[i++] = n % 2;        n /= 2;    }    for(int j = i - 1; j >= 0; j--)        printf("%d", binary[j]);}%}%%[0-9]+ {    int num = atoi(yytext);    printf("Binary of %d = ", num);    dec_to_bin(num);    printf("\n");}.|\n { ECHO; }%%int main() {    yylex();    return 0;}int yywrap() {    return 1;}hextodec%{#include <stdio.h>#include <stdlib.h>%}%%0[xX][0-9a-fA-F]+ {    int num = (int)strtol(yytext, NULL, 16);    printf("Decimal of %s = %d\n", yytext, num);}.|\n { ECHO; }%%int main() {    yylex();    return 0;}int yywrap() {    return 1;}ending with com%{#include <stdio.h>int count = 0;%}%%.*com$   { count++; }       /* Line ending with 'com' */.*       { }                /* Any other line */\n       { }                /* Handle newlines */%%int main() {    printf("Enter text (press Ctrl+Z to end):\n");    yylex();    printf("\nTotal lines ending with 'com' = %d\n", count);    return 0;}int yywrap() { return 1; }ending with edu%{#include <stdio.h>int edu_count = 0;%}%%https?:\/\/[a-zA-Z0-9_.-]+\.edu\/?    { edu_count++; }  /* Match URLs ending with .edu */.|\n                                   { }                /* Ignore other text */%%int main() {    printf("Enter URLs (press Ctrl+Z to end):\n");    yylex();    printf("\nTotal URLs ending with 'edu' = %d\n", edu_count);    return 0;}int yywrap() { return 1; }ending with org%{#include <stdio.h>int org_count = 0;%}%%https?:\/\/[a-zA-Z0-9_.-]+\.org\/?    { org_count++; }  /* Match URLs ending with .org */.|\n                                   { }                /* Ignore other text */%%int main() {    printf("Enter URLs (press Ctrl+Z to end):\n");    yylex();    printf("\nTotal URLs ending with 'org' = %d\n", org_count);    return 0;}int yywrap() { return 1; }1. YACC program for Conversion of Infix to Postfix expression. infix_postfix.l%{#include "infix_postfix.tab.h"#include <stdlib.h>%}%%[0-9]+              { yylval = atoi(yytext); return NUM; }[+\-*/^()]          { return yytext[0]; }[ \t\n]             { /* skip whitespace */ }.                   { printf("Invalid character: %s\n", yytext); }%%int yywrap() { return 1; }infix_postfix.y%{#include <stdio.h>#include <stdlib.h>%}%token NUM%left '+' '-'%left '*' '/'%right '^'%nonassoc '(' ')'%%E : E '+' E     { printf("+ "); }  | E '-' E     { printf("- "); }  | E '*' E     { printf("* "); }  | E '/' E     { printf("/ "); }  | '(' E ')'   { }  | NUM         { printf("%d ", $1); }  ;%%int main() {    printf("Enter infix expression: ");    yyparse();    printf("\n");    return 0;}int yyerror(const char *s) {    printf("Error: %s\n", s);    return 0;}win_bison -d infix_postfix.y -o infix_postfix.tab.cwin_flex infix_postfix.lgcc lex.yy.c infix_postfix.tab.c -o infix_postfix.exe./infix_postfix.exe.YACC program for valuating postfix expressions containing decimal numbers. postfix_eval.l%{#include "postfix_eval.tab.h"#include <stdlib.h>%}%%[0-9]+(\.[0-9]+)?     { yylval.fval = atof(yytext); return NUM; }   /* Match integers or decimals */[+\-*/\n]              { return yytext[0]; }                         /* Operators and newline */[ \t]                  ;                                              /* Ignore spaces and tabs */.                      { printf("Invalid character: %s\n", yytext); }%%int yywrap() { return 1; }postfix_eval.y%{#include <stdio.h>#include <stdlib.h>#include <math.h>int yylex();int yyerror(char *s);%}%union {    double fval;}%token <fval> NUM%type <fval> E%%input:    /* empty */  | input line  ;line:    E '\n'   { printf("Result = %.2f\n", $1); }  ;E:    E E '+'  { $$ = $1 + $2; }  | E E '-'  { $$ = $1 - $2; }  | E E '*'  { $$ = $1 * $2; }  | E E '/'  {                if ($2 == 0) {                    printf("Error: Division by zero\n");                    $$ = 0;                } else $$ = $1 / $2;              }  | NUM      { $$ = $1; }  ;%%int main() {    printf("Enter postfix expression (e.g. 3 4 + 2 *):\n");    yyparse();    return 0;}int yyerror(char *s) {    printf("Error: %s\n", s);    return 0;}win_bison -d postfix_eval.y -o postfix_eval.tab.cwin_flex postfix_eval.lgcc lex.yy.c postfix_eval.tab.c -o postfix_eval.exe./postfix_eval.exedesk calccalc.y%{#include <stdio.h>#include <stdlib.h>#include <math.h>int yylex();int yyerror(char *s);%}%union {    double fval;}%token <fval> NUM%type <fval> E%left '+' '-'%left '*' '/'%right '^'%nonassoc '(' ')'%%input:      /* empty */    | input line    ;line:      E '\n'       { printf("Result = %.2f\n", $1); }    | '\n'    ;E:      E '+' E       { $$ = $1 + $3; }    | E '-' E       { $$ = $1 - $3; }    | E '*' E       { $$ = $1 * $3; }    | E '/' E       {                        if ($3 == 0)                            { printf("Error: Division by zero\n"); $$ = 0; }                        else                            $$ = $1 / $3;                     }    | E '^' E       { $$ = pow($1, $3); }    | '(' E ')'     { $$ = $2; }    | NUM           { $$ = $1; }    ;%%int main() {    printf("Enter arithmetic expressions (Ctrl+Z to exit):\n");    yyparse();    return 0;}int yyerror(char *s) {    printf("Error: %s\n", s);    return 0;}calc.l%{#include "calc.tab.h"#include <stdlib.h>%}%%[0-9]+(\.[0-9]+)?     { yylval.fval = atof(yytext); return NUM; }   /* Match integers or decimals */[+\-*/^()]            { return yytext[0]; }                         /* Operators and parentheses */[ \t]                 ;                                              /* Ignore whitespace */\n                    { return '\n'; }                               /* Newline ends expression */.                     { printf("Invalid character: %s\n", yytext); }%%int yywrap() { return 1; }win_bison -d calc.y -o calc.tab.cwin_flex calc.lgcc lex.yy.c calc.tab.c -o calc.exe -lm./calc.exewhile loopwhile.l%{#include "while.tab.h"%}%%"while"             { return WHILE; }"("                 { return '('; }")"                 { return ')'; }"{"                 { return '{'; }"}"                 { return '}'; }[a-zA-Z_][a-zA-Z0-9_]*   { return ID; }[ \t\n]             ;.                   { printf("Invalid token: %s\n", yytext); }%%int yywrap() { return 1; }while.y%{#include <stdio.h>int yylex();int yyerror(char *s);%}%token WHILE ID%%S : WHILE '(' C ')' '{' STMT '}'   { printf("Valid WHILE loop syntax.\n"); }  ;C : ID                             { /* simple condition */ }  ;STMT : ID                          { /* dummy statement */ }     ;%%int main() {    printf("Enter a while loop: ");    yyparse();    return 0;}int yyerror(char *s) {    printf("Invalid WHILE syntax.\n");    return 0;}switchswitch.l%{#include "switch.tab.h"%}%%"switch"    { return SWITCH; }"case"      { return CASE; }"break"     { return BREAK; }"default"   { return DEFAULT; }"("         { return '('; }")"         { return ')'; }"{"         { return '{'; }"}"         { return '}'; }":"         { return ':'; }[a-zA-Z_][a-zA-Z0-9_]*  { return ID; }[0-9]+      { return NUM; }[ \t\n]     ;.           { printf("Invalid token: %s\n", yytext); }%%int yywrap() { return 1; }switch.y%{#include <stdio.h>int yylex();int yyerror(char *s);%}%token SWITCH CASE BREAK DEFAULT ID NUM%%S : SWITCH '(' ID ')' '{' CLIST DEFAULT ':' STMT '}'  { printf("Valid SWITCH syntax.\n"); }  ;CLIST : CLIST CASE NUM ':' STMT BREAK ';'      | CASE NUM ':' STMT BREAK ';'      ;STMT : ID ;%%int main() {    printf("Enter a switch statement: ");    yyparse();    return 0;}int yyerror(char *s) {    printf("Invalid SWITCH syntax.\n");    return 0;}if-thenifthen.l%{#include "ifthen.tab.h"%}%%"if"        { return IF; }"then"      { return THEN; }[a-zA-Z_][a-zA-Z0-9_]*  { return ID; }[ \t\n]     ;.           { printf("Invalid token: %s\n", yytext); }%%int yywrap() { return 1; }ifthen.y%{#include <stdio.h>int yylex();int yyerror(char *s);%}%token IF THEN ID%%S : IF C THEN STMT   { printf("Valid IF-THEN syntax.\n"); }  ;C : ID ;STMT : ID ;%%int main() {    printf("Enter an if-then statement: ");    yyparse();    return 0;}int yyerror(char *s) {    printf("Invalid IF-THEN syntax.\n");    return 0;}if-elseifelse.l%{#include "ifelse.tab.h"%}%%"if"        { return IF; }"then"      { return THEN; }"else"      { return ELSE; }[a-zA-Z_][a-zA-Z0-9_]*  { return ID; }[ \t\n]     ;.           { printf("Invalid token: %s\n", yytext); }%%int yywrap() { return 1; }ifelse.y%{#include <stdio.h>int yylex();int yyerror(char *s);%}%token IF THEN ELSE ID%%S : IF C THEN STMT ELSE STMT   { printf("Valid IF-THEN-ELSE syntax.\n"); }  ;C : ID ;STMT : ID ;%%int main() {    printf("Enter an if-then-else statement: ");    yyparse();    return 0;}int yyerror(char *s) {    printf("Invalid IF-THEN-ELSE syntax.\n");    return 0;}Custom Functionsfunc.l%{#include "func.tab.h"%}%%[a-zA-Z_][a-zA-Z0-9_]*   { return ID; }"("                      { return '('; }")"                      { return ')'; }"{"                      { return '{'; }"}"                      { return '}'; }","                      { return ','; }[ \t\n]                  ;.                        { printf("Invalid token: %s\n", yytext); }%%int yywrap() { return 1; }func.y%{#include <stdio.h>int yylex();int yyerror(char *s);%}%token ID%%S : ID '(' PARAMS ')' '{' BODY '}'   { printf("Valid FUNCTION syntax.\n"); }  ;PARAMS : ID       | PARAMS ',' ID       | /* empty */       ;BODY : ID     | BODY ID     ;%%int main() {    printf("Enter a function definition: ");    yyparse();    return 0;}int yyerror(char *s) {    printf("Invalid FUNCTION syntax.\n");    return 0;}win_bison -d filename.y       // Generates filename.tab.c and filename.tab.hwin_flex filename.l           // Generates lex.yy.cgcc lex.yy.c filename.tab.c -o filename.exe./filename.exe                // Run the programACC program for IC generation for the expression involving parenthesis.expr_ic.l%{#include "expr_ic.tab.h"#include <string.h>%}%%[0-9]+              { yylval.str = strdup(yytext); return NUM; }[a-zA-Z][a-zA-Z0-9]* { yylval.str = strdup(yytext); return ID; }[+\-*/()=]          { return yytext[0]; }[ \t\n]             ;.                   { printf("Invalid character: %s\n", yytext); }%%int yywrap() { return 1; }expr_ic.y%{#include <stdio.h>#include <stdlib.h>int tempCount = 1;char temp[10];void newTemp() {    sprintf(temp, "t%d", tempCount++);}int yylex();int yyerror(char *s);%}%token ID NUM%left '+' '-'%left '*' '/'%left '(' ')'%%S : E { printf("Final Result in %s\n", temp); }  ;E : E '+' T  { newTemp(); printf("%s = %s + %s\n", temp, $1, $3); $$ = strdup(temp); }  | E '-' T  { newTemp(); printf("%s = %s - %s\n", temp, $1, $3); $$ = strdup(temp); }  | T        { $$ = $1; }  ;T : T '*' F  { newTemp(); printf("%s = %s * %s\n", temp, $1, $3); $$ = strdup(temp); }  | T '/' F  { newTemp(); printf("%s = %s / %s\n", temp, $1, $3); $$ = strdup(temp); }  | F        { $$ = $1; }  ;F : '(' E ')' { $$ = $2; }  | ID        { $$ = strdup(yytext); }  | NUM       { $$ = strdup(yytext); }  ;%%int yyerror(char *s) {    printf("Error: %s\n", s);    return 0;}int main() {    printf("Enter expression: ");    yyparse();    return 0;}a = (b + c) * d. YACC program for IC generation for the expression involving programming constructs.construct_ic.y%{#include <stdio.h>#include <stdlib.h>#include <string.h>int yylex();void yyerror(const char *s);extern char *yytext;char tempVar[10];int tempCount = 0;void newTemp() {    sprintf(tempVar, "t%d", tempCount++);}%}%union {    char *str;}%token <str> ID NUM RELOP%token IF ELSE WHILE%type <str> E T F C%nonassoc LOWER_THAN_ELSE%nonassoc ELSE%%S : STMT  ;STMT : C ';'                        { printf("Condition Result: %s\n", $1); }     | ID '=' E ';'                 { newTemp(); printf("%s = %s\n", $1, $3); }     | IF '(' C ')' STMT %prec LOWER_THAN_ELSE                                    { printf("if %s goto true_label\n", $3); }     | IF '(' C ')' STMT ELSE STMT  { printf("if %s goto true_label else false_label\n", $3); }     | WHILE '(' C ')' STMT         { printf("while %s loop\n", $3); }     | '{' STMT_LIST '}'            { }     ;STMT_LIST : STMT_LIST STMT          | STMT          ;C : E RELOP E                       { newTemp(); printf("%s = %s %s %s\n", tempVar, $1, $2, $3); $$ = strdup(tempVar); }  ;E : E '+' T                         { newTemp(); printf("%s = %s + %s\n", tempVar, $1, $3); $$ = strdup(tempVar); }  | E '-' T                         { newTemp(); printf("%s = %s - %s\n", tempVar, $1, $3); $$ = strdup(tempVar); }  | T                               { $$ = $1; }  ;T : T '*' F                         { newTemp(); printf("%s = %s * %s\n", tempVar, $1, $3); $$ = strdup(tempVar); }  | T '/' F                         { newTemp(); printf("%s = %s / %s\n", tempVar, $1, $3); $$ = strdup(tempVar); }  | F                               { $$ = $1; }  ;F : '(' E ')'                       { $$ = $2; }  | ID                              { $$ = $1; }  | NUM                             { $$ = $1; }  ;%%void yyerror(const char *s) {    fprintf(stderr, "Error: %s\n", s);}int main() {    printf("Enter an expression or construct:\n");    yyparse();    return 0;}construct_ic.l%{#include <stdio.h>#include <stdlib.h>#include <string.h>#include "construct_ic.tab.h"%}%%"if"                        { return IF; }"else"                      { return ELSE; }"while"                     { return WHILE; }[0-9]+                      { yylval.str = strdup(yytext); return NUM; }[a-zA-Z_][a-zA-Z0-9_]*      { yylval.str = strdup(yytext); return ID; }">="|"<="|"=="|"!="|">"|"<" { yylval.str = strdup(yytext); return RELOP; }"("                         { return '('; }")"                         { return ')'; }"{"                         { return '{'; }"}"                         { return '}'; }[+\-*/=;]                   { return yytext[0]; }[ \t\n\r]                   ;  /* ignore whitespace */.                           { printf("Unknown character: %s\n", yytext); }%%int yywrap() { return 1; }